---
# Requiere variables externas:
# - portainer_url (https://HOST:9443)
# - portainer_api_token (API Key)
# - portainer_validate_certs (bool)
# - st: { name, endpoint, repo_url, compose_path, git_ref, env: [ {name,value}, ... ] }
# - endpoint_id (int) → ya resuelto por el play que incluye esta tarea

# ====== Preparación del workspace local ======
- name: Definir carpetas locales
  ansible.builtin.set_fact:
    _git_base: "{{ lookup('env','HOME') ~ '/.cache/portainer-stacks' }}"
    _repo_dir: "{{ lookup('env','HOME') ~ '/.cache/portainer-stacks/' ~ (st.repo_url | regex_replace('[^A-Za-z0-9_.-]','_')) ~ '_' ~ (st.git_ref | default('main')) }}"
    _compose_rel: "{{ st.compose_path }}"
    _compose_abs: "{{ _repo_dir ~ '/' ~ st.compose_path }}"
    _compose_dir: "{{ (_repo_dir ~ '/' ~ st.compose_path) | dirname }}"
    _dotenv_abs: "{{ (_repo_dir ~ '/' ~ st.compose_path) | dirname ~ '/.env' }}"

- name: Crear base de trabajo local
  ansible.builtin.file:
    path: "{{ _git_base }}"
    state: directory
    mode: "0755"
  delegate_to: localhost
  run_once: true

# ====== Clonado/actualización del repo (local) ======
- name: Preparar GIT_SSH_COMMAND si hay deploy key inline
  ansible.builtin.set_fact:
    _git_ssh_command: >-
      {{ 'ssh -o StrictHostKeyChecking=accept-new -i ' ~ github_deploy_key_path
         if (github_deploy_key_path is defined and github_deploy_key_path|length>0)
         else omit }}
  when: github_deploy_key_path is defined and github_deploy_key_path|length > 0
  delegate_to: localhost
  run_once: true

- name: Escribir deploy key a archivo temporal (si viene como contenido)
  ansible.builtin.copy:
    dest: "{{ _git_base }}/id_rsa"
    content: "{{ github_deploy_key }}"
    mode: "0600"
  when: github_deploy_key is defined and github_deploy_key|length > 0
  delegate_to: localhost
  run_once: true

- name: Preparar GIT_SSH_COMMAND (si deploy key fue escrita)
  ansible.builtin.set_fact:
    _git_ssh_command: "ssh -o StrictHostKeyChecking=accept-new -i {{ _git_base }}/id_rsa"
  when: github_deploy_key is defined and github_deploy_key|length > 0
  delegate_to: localhost
  run_once: true

- name: Clonar/actualizar repo {{ st.repo_url }} ({{ st.git_ref | default('main') }})
  ansible.builtin.git:
    repo: "{{ st.repo_url }}"
    dest: "{{ _repo_dir }}"
    version: "{{ st.git_ref | default('main') }}"
    accept_hostkey: true
    update: true
  environment: >-
    {{ ({ 'GIT_SSH_COMMAND': _git_ssh_command } if _git_ssh_command is defined else {}) }}
  delegate_to: localhost

# ====== Leer compose y .env, y normalizar Env ======
- name: Verificar que el compose exista
  ansible.builtin.stat:
    path: "{{ _compose_abs }}"
  register: _compose_stat
  delegate_to: localhost

- name: Fallar si no existe el compose
  ansible.builtin.assert:
    that: _compose_stat.stat.exists
    fail_msg: "No se encontró el compose en {{ _compose_abs }}"

- name: Leer contenido del compose
  ansible.builtin.slurp:
    src: "{{ _compose_abs }}"
  register: _compose_raw
  delegate_to: localhost

- name: Decodificar compose (texto)
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_raw.content | b64decode }}"
  delegate_to: localhost

# Parsear .env si existe
- name: Verificar si existe .env al lado del compose
  ansible.builtin.stat:
    path: "{{ _dotenv_abs }}"
  register: _dotenv_stat
  delegate_to: localhost

- name: Leer .env si existe
  ansible.builtin.slurp:
    src: "{{ _dotenv_abs }}"
  register: _dotenv_raw
  when: _dotenv_stat.stat.exists
  delegate_to: localhost

- name: Parsear .env a dict
  ansible.builtin.set_fact:
    _env_from_dotenv: >-
      {{
        dict( (_dotenv_raw.content | default('') | b64decode).splitlines()
                | select('match','^[A-Za-z_][A-Za-z0-9_]*=.*$')
                | map('regex_replace','^([^=]+)=(.*)$','\\1|\\2')
                | map('split','|',1)
            )
      }}
  when: _dotenv_stat.stat.exists
  delegate_to: localhost

- name: Convertir dict .env a lista Env
  ansible.builtin.set_fact:
    _env_list_from_dotenv: >-
      {{ (_env_from_dotenv | default({})).keys()
          | list
          | map('community.general.dict_kv', _env_from_dotenv)
          | map('extract', 'item')
          | map('combine', {'name': item.key, 'value': item.value})
          | list }}
  vars:
    item: "{{ item | default({}) }}"
  delegate_to: localhost

# Fusionar Env: st.env tiene prioridad sobre .env
- name: Fusionar variables de entorno (st.env sobre .env)
  ansible.builtin.set_fact:
    _env_final: >-
      {{
        (
          dict( (_env_list_from_dotenv | default([])) | map(attribute='name') | zip((_env_list_from_dotenv | default([])) | map(attribute='value')) )
          | combine( dict( (st.env | default([])) | map(attribute='name') | zip((st.env | default([])) | map(attribute='value')) ), recursive=True)
        )
        | dict2items(key_name='name', value_name='value')
      }}
  delegate_to: localhost

# ====== Sanitizar compose: remover env_file ======
- name: Remover env_file (línea simple)
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_text | regex_replace('(?m)^\\s*env_file\\s*:\\s*\\.env\\s*$', '') }}"
  delegate_to: localhost

- name: Remover env_file con lista inline
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_text | regex_replace('(?s)env_file\\s*:\\s*\\[.*?\\]', '') }}"
  delegate_to: localhost

- name: Remover bloque env_file multilínea
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_text | regex_replace('(?s)^\\s*env_file\\s*:\\s*\\n(\\s*[-].*\\n)+', '') }}"
  delegate_to: localhost

# ====== Portainer: buscar stack existente por Name+EndpointId ======
- name: Listar stacks en Portainer
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks?filters={{ {'EndpointId': endpoint_id} | to_json | urlencode }}"
    method: GET
    headers: { X-API-Key: "{{ portainer_api_token }}" }
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    return_content: true
    status_code: 200
  register: _stacks_list

- name: Calcular si el stack existe en el endpoint
  ansible.builtin.set_fact:
    _matching: "{{ _stacks_list.json | selectattr('Name','equalto', st.name) | list }}"
    _exists: "{{ (_stacks_list.json | selectattr('Name','equalto', st.name) | list | length) > 0 }}"
    _stack_id: "{{ (_stacks_list.json | selectattr('Name','equalto', st.name) | list | first).Id if (_stacks_list.json | selectattr('Name','equalto', st.name) | list | length)>0 else 0 }}"

- name: Debug coincidencia
  ansible.builtin.debug:
    msg:
      - "EndpointId={{ endpoint_id }} | Stack '{{ st.name }}' existe? {{ _exists }}"
      - "StackId={{ _stack_id | default('N/A') }}"

# ====== Crear o actualizar ======
- name: Crear stack (POST /create/standalone/string)
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks/create/standalone/string?endpointId={{ endpoint_id }}"
    method: POST
    headers:
      X-API-Key: "{{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    body_format: json
    body:
      Name: "{{ st.name }}"
      StackFileContent: "{{ _compose_text }}"
      Env: "{{ _env_final | default([]) }}"
      Prune: true
    status_code: [200,201]
    return_content: true
  when: not _exists
  register: _create_resp

- name: Actualizar stack existente (PUT /stacks/{id})
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks/{{ _stack_id }}?endpointId={{ endpoint_id }}"
    method: PUT
    headers:
      X-API-Key: "{{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    body_format: json
    body:
      Prune: true
      StackFileContent: "{{ _compose_text }}"
      Env: "{{ _env_final | default([]) }}"
    status_code: 200
    return_content: true
  when: _exists
  register: _update_resp

- name: Resultado
  ansible.builtin.debug:
    msg: >-
      {{
        _exists
        | ternary(
            'Actualizado stack ' ~ st.name ~ ' (id=' ~ _stack_id | string ~ ')',
            'Creado stack ' ~ st.name ~ ' (id=' ~ (_create_resp.json.Id | default("desconocido")) | string ~ ')'
          )
      }}