---
# Requiere vars del item: st.name, st.endpoint, st.repo_url, st.compose_path, st.git_ref, st.env
# Requiere vars del play: portainer_url, portainer_api_token, endpoints (mapa), portainer_validate_certs
# Opcional (repo privado por SSH): github_deploy_key (ruta a la key)

# === 0) Resolver endpointId ===
- name: Resolver endpointId para {{ st.name }}
  ansible.builtin.set_fact:
    _endpoint_id: "{{ (endpoints[st.endpoint] | default(omit)) | int }}"

- name: Validar endpointId mapeado
  ansible.builtin.assert:
    that:
      - _endpoint_id is defined
    fail_msg: "No encuentro endpointId para '{{ st.endpoint }}' en 'endpoints: {}'"
    success_msg: "endpointId = {{ _endpoint_id }}"

# === 1) Preparar compose localmente (control node) ===
- name: Clonar repo {{ st.repo_url }} ({{ st.git_ref | default('main') }}) localmente
  ansible.builtin.git:
    repo: "{{ st.repo_url }}"
    dest: "/tmp/portainer_repos/{{ st.name }}"
    version: "{{ st.git_ref | default('main') }}"
    accept_hostkey: true
    key_file: "{{ github_deploy_key | default(omit) }}"
    update: true
    force: true
  delegate_to: localhost
  run_once: true

- name: Verificar archivo compose existe
  ansible.builtin.stat:
    path: "/tmp/portainer_repos/{{ st.name }}/{{ st.compose_path }}"
  register: _compose_stat
  delegate_to: localhost
  run_once: true

- name: Fallar si no existe el compose
  ansible.builtin.fail:
    msg: "No se encuentra el compose en {{ st.compose_path }} para stack {{ st.name }}"
  when: not _compose_stat.stat.exists
  delegate_to: localhost
  run_once: true

- name: Leer contenido del compose
  ansible.builtin.slurp:
    path: "/tmp/portainer_repos/{{ st.name }}/{{ st.compose_path }}"
  register: _compose_b64
  delegate_to: localhost
  run_once: true

- name: Guardar contenido compose decodificado
  ansible.builtin.set_fact:
    _compose_content: "{{ _compose_b64.content | b64decode }}"

# === 2) Cargar .env (si existe) y SANEAR compose (quitar cualquier env_file) ===
- name: Construir ruta absoluta del compose
  ansible.builtin.set_fact:
    _compose_abs: "/tmp/portainer_repos/{{ st.name }}/{{ st.compose_path }}"

- name: Calcular directorio del compose
  ansible.builtin.set_fact:
    _compose_dir: "{{ _compose_abs | dirname }}"

- name: Calcular ruta del .env junto al compose
  ansible.builtin.set_fact:
    _env_file_path: "{{ _compose_dir }}/.env"

- name: Verificar si existe .env
  ansible.builtin.stat:
    path: "{{ _env_file_path }}"
  register: _env_stat
  delegate_to: localhost
  run_once: true

- name: Leer .env si existe
  ansible.builtin.slurp:
    path: "{{ _env_file_path }}"
  when: _env_stat.stat.exists
  register: _env_b64
  delegate_to: localhost
  run_once: true

- name: Parsear .env a lista Env (name/value)
  ansible.builtin.set_fact:
    _env_list: >-
      {{
        (_env_b64.content | default('') | b64decode).splitlines()
        | select('match','^[A-Za-z_][A-Za-z0-9_]*=.*$')
        | map('regex_replace','^([A-Za-z_][A-Za-z0-9_]*)=(.*)$','{"name":"\\1","value":"\\2"}')
        | map('from_json')
        | list
      }}
  when: _env_stat.stat.exists

# Saneo de env_file
- name: Remover env_file .env (línea simple)
  ansible.builtin.set_fact:
    _compose_step1: "{{ _compose_content | regex_replace('(?m)^\\s*env_file\\s*:\\s*\\.?/?\\.env\\s*$', '') }}"

- name: Remover env_file con corchetes
  ansible.builtin.set_fact:
    _compose_step2: "{{ (_compose_step1 | default(_compose_content))
                       | regex_replace('(?mi)^\\s*env_file\\s*:\\s*\\[[^\\]]*\\]\\s*$', '') }}"

- name: Remover bloque env_file con lista
  ansible.builtin.set_fact:
    _compose_step3: >-
      {{
        (_compose_step2 | default(_compose_content))
        | regex_replace('(?ms)^\\s*env_file\\s*:\\s*\\n(?:\\s*-\\s*\\.?/?\\.env\\s*\\n)+', '')
      }}

- name: Remover líneas sueltas de .env
  ansible.builtin.set_fact:
    _compose_final: "{{ (_compose_step3 | default(_compose_content))
                       | regex_replace('(?m)^\\s*-\\s*\\.?/?\\.env\\s*$', '') }}"

# === 3) Descubrir si el stack existe ===
- name: Listar stacks existentes (Portainer)
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks"
    method: GET
    headers:
      X-API-Key: "{{ portainer_api_token }}"
      Accept: "application/json"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    return_content: true
    status_code: 200
    timeout: "{{ portainer_api_timeout | default(60) }}"
    follow_redirects: all
  register: _stacks_list

- name: Calcular lista de coincidencias
  ansible.builtin.set_fact:
    _matches: >-
      {{
        _stacks_list.json
        | selectattr('Name','equalto', st.name)
        | selectattr('EndpointId','equalto', (_endpoint_id | int))
        | list
      }}

- name: Derivar flags de existencia y stack existente
  ansible.builtin.set_fact:
    _exists: "{{ (_matches | length) | int > 0 }}"
    _existing_stack: "{{ _matches[0] if ((_matches | length) | int > 0) else omit }}"

- name: Debug match
  ansible.builtin.debug:
    msg:
      - "Stack '{{ st.name }}' en endpoint {{ _endpoint_id }} => {{ 'EXISTE' if _exists else 'NO EXISTE' }}"

# === 4) Si existe: borrar ===
- name: Borrar stack existente (si aplica)
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks/{{ _existing_stack.Id }}?endpointId={{ _endpoint_id }}"
    method: DELETE
    headers:
      X-API-Key: "{{ portainer_api_token }}"
      Accept: "application/json"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: 204
    timeout: "{{ portainer_api_timeout | default(300) }}"
    follow_redirects: all
  when: _exists
  register: _delete_resp
  changed_when: _exists

# === 5) Crear stack (JSON) con timeout alto + retry; fallback form-urlencoded limpio ===
- name: POST /api/stacks/create/standalone/string (JSON) con timeout alto
  block:
    - name: Intento JSON
      ansible.builtin.uri:
        url: "{{ portainer_url }}/api/stacks/create/standalone/string?endpointId={{ _endpoint_id }}"
        method: POST
        headers:
          X-API-Key: "{{ portainer_api_token }}"
          Accept: "application/json"
          Content-Type: "application/json"
        validate_certs: "{{ portainer_validate_certs | default(false) }}"
        body_format: json
        body:
          name: "{{ st.name }}"
          stackFileContent: "{{ _compose_final | default(_compose_content) }}"
          env: "{{ (st.env | default([])) + (_env_list | default([])) }}"
          prune: true
          pullImage: true
        status_code: [200, 201]
        timeout: "{{ portainer_api_timeout | default(300) }}"
        follow_redirects: all
      register: _create_json
      changed_when: true
      retries: 2
      delay: 5
      until: _create_json.status in [200, 201]
  rescue:
    - name: Fallback form-urlencoded (deja que Ansible codifique el formulario)
      ansible.builtin.uri:
        url: "{{ portainer_url }}/api/stacks/create/standalone/string?endpointId={{ _endpoint_id }}"
        method: POST
        headers:
          X-API-Key: "{{ portainer_api_token }}"
          Accept: "application/json"
        validate_certs: "{{ portainer_validate_certs | default(false) }}"
        body_format: form-urlencoded
        body:
          Name: "{{ st.name }}"
          StackFileContent: "{{ _compose_final | default(_compose_content) }}"
          Prune: "true"
          PullImage: "true"
          Env: "{{ ((st.env | default([])) + (_env_list | default([]))) | to_json }}"
        status_code: [200, 201]
        timeout: "{{ portainer_api_timeout | default(300) }}"
        follow_redirects: all
      register: _create_form
      changed_when: true