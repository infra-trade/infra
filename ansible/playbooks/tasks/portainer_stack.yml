---
# Requiere variables externas:
# - portainer_url (https://HOST:9443)
# - portainer_api_token (API Key)
# - portainer_validate_certs (bool)
# - st: { name, endpoint, repo_url, compose_path, git_ref, env: [ {name,value}, ... ] }
# - endpoint_id (int) → ya resuelto por el task que incluye este archivo
# - Variables de workspace (_git_base, _repo_dir, _compose_abs, _compose_dir, _dotenv_abs) predefinidas por el resolver
# - prefer_host_ssh_key (bool, opcional): por defecto true → usa ~/.ssh/id_ed25519

# ====== Preparación del workspace local ======
- name: Definir carpetas locales (solo si no vienen predefinidas)
  ansible.builtin.set_fact:
    _git_base: "{{ _git_base | default(lookup('env','HOME') ~ '/.cache/portainer-stacks') }}"
    _repo_dir: "{{ _repo_dir | default( lookup('env','HOME') ~ '/.cache/portainer-stacks/' ~ (st.repo_url | regex_replace('[^A-Za-z0-9_.-]','_')) ~ '_' ~ (st.git_ref | default('main')) ) }}"
    _compose_rel: "{{ _compose_rel | default(st.compose_path) }}"
    _compose_abs: "{{ _compose_abs | default(_repo_dir ~ '/' ~ st.compose_path) }}"
    _compose_dir: "{{ _compose_dir | default((_repo_dir ~ '/' ~ st.compose_path) | dirname) }}"
    _dotenv_abs: "{{ _dotenv_abs | default((_repo_dir ~ '/' ~ st.compose_path) | dirname ~ '/.env') }}"
  when: _repo_dir is not defined

- name: Crear base de trabajo local
  ansible.builtin.file:
    path: "{{ _git_base }}"
    state: directory
    mode: "0755"
  delegate_to: localhost
  run_once: true

# ====== Preferir clave del host a menos que se pida lo contrario ======
- name: Force using host SSH key (id_ed25519) unless told otherwise
  ansible.builtin.set_fact:
    _git_ssh_command: "ssh -i {{ lookup('env','HOME') }}/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=accept-new"
  when: prefer_host_ssh_key | default(true) | bool
  delegate_to: localhost
  run_once: true

# ====== Clonado/actualización del repo (local) ======
- name: Preparar GIT_SSH_COMMAND si hay deploy key en ruta (y no se fuerza host key)
  ansible.builtin.set_fact:
    _git_ssh_command: >-
      {{ 'ssh -o StrictHostKeyChecking=accept-new -o IdentitiesOnly=yes -i ' ~ github_deploy_key_path
         if (github_deploy_key_path is defined and github_deploy_key_path|length>0)
         else omit }}
  when: (github_deploy_key_path is defined and github_deploy_key_path|length > 0) and not (prefer_host_ssh_key | default(true) | bool)
  delegate_to: localhost
  run_once: true

- name: Escribir deploy key a archivo temporal (si viene como contenido y no se fuerza host key)
  ansible.builtin.copy:
    dest: "{{ _git_base }}/id_rsa"
    content: "{{ github_deploy_key }}"
    mode: "0600"
  when: (github_deploy_key is defined and github_deploy_key|length > 0) and not (prefer_host_ssh_key | default(true) | bool)
  delegate_to: localhost
  run_once: true

- name: Validate deploy key format (PEM OpenSSH)
  ansible.builtin.assert:
    that:
      - github_deploy_key is search('^-----BEGIN OPENSSH PRIVATE KEY-----')
  when: (github_deploy_key is defined and github_deploy_key|length > 0) and not (prefer_host_ssh_key | default(true) | bool)
  delegate_to: localhost
  run_once: true

- name: Normalize CRLF in deploy key
  ansible.builtin.replace:
    path: "{{ _git_base }}/id_rsa"
    regexp: '\r'
    replace: ''
  when: (github_deploy_key is defined and github_deploy_key|length > 0) and not (prefer_host_ssh_key | default(true) | bool)
  delegate_to: localhost
  run_once: true

- name: Preparar GIT_SSH_COMMAND (si deploy key fue escrita y no se fuerza host key)
  ansible.builtin.set_fact:
    _git_ssh_command: "ssh -o StrictHostKeyChecking=accept-new -o IdentitiesOnly=yes -i {{ _git_base }}/id_rsa"
  when: (github_deploy_key is defined and github_deploy_key|length > 0) and not (prefer_host_ssh_key | default(true) | bool)
  delegate_to: localhost
  run_once: true

# Fallback: si por alguna razón aún no hay _git_ssh_command, usa la host key
- name: Ensure _git_ssh_command is set (fallback to host key)
  ansible.builtin.set_fact:
    _git_ssh_command: "ssh -i {{ lookup('env','HOME') }}/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=accept-new"
  when: _git_ssh_command is not defined
  delegate_to: localhost
  run_once: true

- name: Clonar/actualizar repo {{ st.repo_url }} ({{ st.git_ref | default('main') }})
  ansible.builtin.git:
    repo: "{{ st.repo_url }}"
    dest: "{{ _repo_dir }}"
    version: "{{ st.git_ref | default('main') }}"
    accept_hostkey: true
    update: true
  environment:
    GIT_SSH_COMMAND: "{{ _git_ssh_command }}"
  delegate_to: localhost

# ====== Leer compose ======
- name: Verificar que el compose exista
  ansible.builtin.stat:
    path: "{{ _compose_abs }}"
  register: _compose_stat
  delegate_to: localhost

- name: Fallar si no existe el compose
  ansible.builtin.assert:
    that: _compose_stat.stat.exists
    fail_msg: "No se encontró el compose en {{ _compose_abs }}"

- name: Leer contenido del compose
  ansible.builtin.slurp:
    src: "{{ _compose_abs }}"
  register: _compose_raw
  delegate_to: localhost

- name: Decodificar compose (texto)
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_raw.content | b64decode }}"
  delegate_to: localhost

# ====== .env opcional y fusión con st.env ======
- name: Verificar si existe .env al lado del compose
  ansible.builtin.stat:
    path: "{{ _dotenv_abs }}"
  register: _dotenv_stat
  delegate_to: localhost

- name: Leer .env si existe
  ansible.builtin.slurp:
    src: "{{ _dotenv_abs }}"
  register: _dotenv_raw
  when: _dotenv_stat.stat.exists
  delegate_to: localhost

- name: Parsear .env a dict
  ansible.builtin.set_fact:
    _env_from_dotenv: >-
      {{
        dict( (_dotenv_raw.content | default('') | b64decode).splitlines()
                | select('match','^[A-Za-z_][A-Za-z0-9_]*=.*$')
                | map('regex_replace','^([^=]+)=(.*)$','\\1|\\2')
                | map('split','|',1)
            )
      }}
  when: _dotenv_stat.stat.exists
  delegate_to: localhost

- name: Construir overrides desde st.env (lista -> dict)
  ansible.builtin.set_fact:
    _env_overrides: "{{ dict( (st.env | default([])) | map(attribute='name') | zip((st.env | default([])) | map(attribute='value')) ) }}"
  delegate_to: localhost

- name: Fusionar .env con overrides (st.env tiene prioridad)
  ansible.builtin.set_fact:
    _env_merged_dict: "{{ (_env_from_dotenv | default({})) | combine(_env_overrides, recursive=True) }}"
  delegate_to: localhost

- name: Preparar _env_final para Portainer (lista de {name,value})
  ansible.builtin.set_fact:
    _env_final: "{{ _env_merged_dict | dict2items(key_name='name', value_name='value') }}"
  delegate_to: localhost

# ====== Sanitizar compose: remover env_file (para no depender del archivo) ======
- name: Remover env_file (línea simple)
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_text | regex_replace('(?m)^\\s*env_file\\s*:\\s*\\.env\\s*$', '') }}"
  delegate_to: localhost

- name: Remover env_file con lista inline
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_text | regex_replace('(?s)env_file\\s*:\\s*\\[.*?\\]', '') }}"
  delegate_to: localhost

- name: Remover bloque env_file multilínea
  ansible.builtin.set_fact:
    _compose_text: "{{ _compose_text | regex_replace('(?s)^\\s*env_file\\s*:\\s*\\n(\\s*[-].*\\n)+', '') }}"
  delegate_to: localhost

# ====== Portainer: buscar stack existente por Name+EndpointId ======
- name: Listar stacks en Portainer
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks?filters={{ {'EndpointId': (endpoint_id | int)} | to_json | urlencode }}""
    method: GET
    headers:
      X-API-Key: "{{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    return_content: true
    status_code: 200
  register: _stacks_list

- name: Calcular si el stack existe en el endpoint
  ansible.builtin.set_fact:
    _matching: "{{ _stacks_list.json | selectattr('Name','equalto', st.name) | list }}"
    _exists: "{{ (_stacks_list.json | selectattr('Name','equalto', st.name) | list | length) > 0 }}"
    _stack_id: "{{ (_stacks_list.json | selectattr('Name','equalto', st.name) | list | first).Id if (_stacks_list.json | selectattr('Name','equalto', st.name) | list | length)>0 else 0 }}"

- name: Debug coincidencia
  ansible.builtin.debug:
    msg:
      - "EndpointId={{ endpoint_id }} | Stack '{{ st.name }}' existe? {{ _exists }}"
      - "StackId={{ _stack_id | default('N/A') }}"

# ====== Crear o actualizar ======
- name: Crear stack (POST /create/standalone/string)
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks/create/standalone/string?endpointId={{ endpoint_id }}"
    method: POST
    headers:
      X-API-Key: "{{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    body_format: json
    body:
      Name: "{{ st.name }}"
      StackFileContent: "{{ _compose_text }}"
      Env: "{{ _env_final | default([]) }}"
      Prune: true
    status_code: [200,201]
    return_content: true
  when: not _exists
  register: _create_resp

- name: Actualizar stack existente (PUT /stacks/{id})
  ansible.builtin.uri:
    url: "{{ portainer_url }}/api/stacks/{{ _stack_id }}?endpointId={{ endpoint_id }}"
    method: PUT
    headers:
      X-API-Key: "{{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    body_format: json
    body:
      Prune: true
      StackFileContent: "{{ _compose_text }}"
      Env: "{{ _env_final | default([]) }}"
    status_code: 200
    return_content: true
  when: _exists
  register: _update_resp

- name: Resultado
  ansible.builtin.debug:
    msg: >-
      {{
        _exists
        | ternary(
            'Actualizado stack ' ~ st.name ~ ' (id=' ~ _stack_id | string ~ ')',
            'Creado stack ' ~ st.name ~ ' (id=' ~ (_create_resp.json.Id | default("desconocido")) | string ~ ')'
          )
      }}