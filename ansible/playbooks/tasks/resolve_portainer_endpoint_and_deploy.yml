---
# tasks file: playbooks/tasks/resolve_portainer_endpoint_and_deploy.yml

# Variables de entrada esperadas (ya las define el play principal):
# - p_url, p_api_token, p_validate_certs
# - endpoints_by_name_map: dict { Name -> Id }
# - alias_map: dict de alias a nombre real
# - st: dict del stack (name, endpoint, repo_url, compose_path|file_path, git_ref, env, prune?, type?, endpoint_id?)

#######################################################################
# 1) Normalizar campos del stack
#######################################################################
- name: Normalize fields for stack {{ st.name }}
  ansible.builtin.set_fact:
    _name: "{{ st.name }}"
    _endpoint: "{{ st.endpoint | default('local') }}"
    _endpoint_id: "{{ st.endpoint_id | default('') }}"
    _repo_url: "{{ st.repo_url }}"
    _git_ref: "{{ st.git_ref | default('main') }}"
    _file_path: "{{ st.file_path | default(st.compose_path) }}"
    _env_vars: "{{ st.env | default([]) }}"
    _prune: "{{ st.prune | default(true) }}"
    _stack_type: "{{ st.type | default(2) }}"   # 2 = standalone/compose

#######################################################################
# 2) Validaciones mínimas
#######################################################################
- name: Validate required fields for stack {{ st.name }}
  ansible.builtin.assert:
    that:
      - _name | length > 0
      - _repo_url | length > 0
      - _file_path | length > 0
    fail_msg: "Faltan campos requeridos en stack {{ st | to_nice_json }}"
    success_msg: "All assertions passed"

#######################################################################
# 3) Resolver endpointId para el stack actual
#######################################################################
- name: Resolve endpointId for {{ st.name }}
  ansible.builtin.set_fact:
    _endpoint_id_resolved: >-
      {%- if (_endpoint_id | string | length) > 0 -%}
        {{ _endpoint_id | int }}
      {%- elif (_endpoint | string | length) > 0 -%}
        {%- set e = _endpoint -%}
        {%- set target = alias_map.get(e, e) -%}
        {{ (endpoints_by_name_map.get(target) | default(endpoints_by_name_map.get(e)) | default(0)) | int }}
      {%- else -%}
        {{ (endpoints_by_name_map.get('local') | default(0)) | int }}
      {%- endif -%}

- name: Fail if endpoint cannot be resolved for {{ st.name }}
  ansible.builtin.assert:
    that:
      - (_endpoint_id_resolved | int) > 0
    fail_msg: "No se pudo resolver endpointId para {{ st.name }} (endpoint='{{ _endpoint }}')."
    success_msg: "All assertions passed"

#######################################################################
# 4) Obtener lista de stacks (para saber si ya existe)
#######################################################################
- name: Fetch stacks list
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks"
    method: GET
    headers:
      X-API-Key: "{{ p_api_token }}"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200
  register: _stacks

- name: Find existing stack id by name (exact match)
  ansible.builtin.set_fact:
    _existing_stack: "{{ (_stacks.json | selectattr('Name','equalto', _name) | list | first) | default(None) }}"
    _existing_stack_id: "{{ ((_stacks.json | selectattr('Name','equalto', _name) | list | first).Id | default(0)) | int }}"

#######################################################################
# 5) Crear stack desde repositorio (si no existe) con fallback a string
#######################################################################
- name: Try create stack {{ _name }} from repository
  when: (_existing_stack_id | int) == 0
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks?type={{ _stack_type }}&method=repository&endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    # aceptamos también 405 para no fallar (lo gestionamos nosotros)
    status_code: 200, 201, 405
    body_format: json
    body:
      Name: "{{ _name }}"
      RepositoryURL: "{{ _repo_url }}"
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFilePathInRepository: "{{ _file_path }}"
      Env: "{{ _env_vars }}"
  register: _create_repo
  failed_when: false

- name: Decide fallback to method=string on create
  when: (_existing_stack_id | int) == 0
  ansible.builtin.set_fact:
    _must_create_via_string: "{{ (_create_repo.status | default(0) | int) == 405 }}"

# Fallback: clonar repo en el controlador y crear con method=string
- name: Clone repo for {{ _name }} (fallback create via string)
  when: (_existing_stack_id | int) == 0 and (_must_create_via_string | default(false))
  ansible.builtin.git:
    repo: "{{ _repo_url }}"
    version: "{{ _git_ref }}"
    dest: "/tmp/portainer_stack_{{ _name }}"
    accept_hostkey: yes
  delegate_to: localhost
  run_once: true

- name: Read compose file for {{ _name }} (fallback)
  when: (_existing_stack_id | int) == 0 and (_must_create_via_string | default(false))
  ansible.builtin.slurp:
    src: "/tmp/portainer_stack_{{ _name }}/{{ _file_path }}"
  register: _compose_slurp
  delegate_to: localhost
  run_once: true

- name: Set compose content fact (fallback)
  when: (_existing_stack_id | int) == 0 and (_must_create_via_string | default(false))
  ansible.builtin.set_fact:
    _compose_content: "{{ _compose_slurp.content | b64decode }}"

- name: Create stack {{ _name }} via method=string (fallback)
  when: (_existing_stack_id | int) == 0 and (_must_create_via_string | default(false))
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks?type={{ _stack_type }}&method=string&endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 201
    body_format: json
    body:
      Name: "{{ _name }}"
      StackFileContent: "{{ _compose_content }}"
      Env: "{{ _env_vars }}"
  register: _create_string

- name: Cleanup temp repo {{ _name }} (optional)
  when: (_existing_stack_id | int) == 0 and (_must_create_via_string | default(false))
  ansible.builtin.file:
    path: "/tmp/portainer_stack_{{ _name }}"
    state: absent
  delegate_to: localhost
  run_once: true
  failed_when: false

#######################################################################
# 6) Si existe, determinar si es Git-based
#######################################################################
- name: Determine if existing stack {{ _name }} is git-based
  when: (_existing_stack_id | int) > 0
  ansible.builtin.set_fact:
    _is_git_based: >-
      {{
        (_existing_stack is defined) and (_existing_stack is not none) and (
          (_existing_stack.GitConfig is defined) or
          (_existing_stack.RepositoryURL is defined) or
          (_existing_stack.GitRepository is defined)
        )
      }}

#######################################################################
# 7) Intentar actualizar metadatos Git (ref / file path) si es git-based
#######################################################################
- name: Update git ref / file path on existing stack {{ _name }} (best effort)
  when: (_existing_stack_id | int) > 0 and (_is_git_based | default(false))
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/{{ _existing_stack_id }}/git"
    method: PUT
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 405
    body_format: json
    body:
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFilePathInRepository: "{{ _file_path }}"
  register: _update
  failed_when: false

#######################################################################
# 8) Redeploy Git si es git-based (si 405, decidimos recrear)
#######################################################################
- name: Git redeploy existing stack {{ _name }}
  when: (_existing_stack_id | int) > 0 and (_is_git_based | default(false))
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/{{ _existing_stack_id }}/git/redeploy?endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 204, 405
    body_format: json
    body:
      Prune: "{{ _prune }}"
      PullImage: true
      Env: "{{ _env_vars }}"
  register: _redeploy
  failed_when: false

#######################################################################
# 9) Decidir si hay que recrear (si no es git-based o si redeploy devolvió 405)
#######################################################################
- name: Decide if we must recreate stack from repository
  when: (_existing_stack_id | int) > 0
  ansible.builtin.set_fact:
    _must_recreate: >-
      {{
        (not (_is_git_based | default(false)))
        or
        (_redeploy is defined and (_redeploy.status | default(0)) | int == 405)
      }}

#######################################################################
# 10) Borrar stack existente con ID y endpoint correctos (si hay que recrear)
#######################################################################
- name: Delete stack {{ _name }} to recreate from repository
  when: (_existing_stack_id | int) > 0 and (_must_recreate | default(false))
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/{{ _existing_stack_id }}?endpointId={{ _endpoint_id_resolved }}"
    method: DELETE
    headers:
      X-API-Key: "{{ p_api_token }}"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 204
  register: _deleted
  failed_when: false

#######################################################################
# 11) Re-crear desde repositorio (con el mismo fallback a string si 405)
#######################################################################
- name: Try recreate stack {{ _name }} from repository
  when: (_must_recreate | default(false))
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks?type={{ _stack_type }}&method=repository&endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 201, 405
    body_format: json
    body:
      Name: "{{ _name }}"
      RepositoryURL: "{{ _repo_url }}"
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFilePathInRepository: "{{ _file_path }}"
      Env: "{{ _env_vars }}"
  register: _recreate_repo
  failed_when: false

- name: Decide fallback to method=string on recreate
  when: (_must_recreate | default(false))
  ansible.builtin.set_fact:
    _must_recreate_via_string: "{{ (_recreate_repo.status | default(0) | int) == 405 }}"

- name: Clone repo for {{ _name }} (fallback recreate via string)
  when: (_must_recreate_via_string | default(false))
  ansible.builtin.git:
    repo: "{{ _repo_url }}"
    version: "{{ _git_ref }}"
    dest: "/tmp/portainer_stack_{{ _name }}"
    accept_hostkey: yes
  delegate_to: localhost
  run_once: true

- name: Read compose file for {{ _name }} (fallback recreate)
  when: (_must_recreate_via_string | default(false))
  ansible.builtin.slurp:
    src: "/tmp/portainer_stack_{{ _name }}/{{ _file_path }}"
  register: _compose_slurp_re
  delegate_to: localhost
  run_once: true

- name: Set compose content fact (fallback recreate)
  when: (_must_recreate_via_string | default(false))
  ansible.builtin.set_fact:
    _compose_content_re: "{{ _compose_slurp_re.content | b64decode }}"

- name: Recreate stack {{ _name }} via method=string (fallback)
  when: (_must_recreate_via_string | default(false))
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks?type={{ _stack_type }}&method=string&endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 201
    body_format: json
    body:
      Name: "{{ _name }}"
      StackFileContent: "{{ _compose_content_re }}"
      Env: "{{ _env_vars }}"
  register: _recreate_string
  failed_when: false

- name: Cleanup temp repo {{ _name }} (optional, recreate)
  when: (_must_recreate_via_string | default(false))
  ansible.builtin.file:
    path: "/tmp/portainer_stack_{{ _name }}"
    state: absent
  delegate_to: localhost
  run_once: true
  failed_when: false

#######################################################################
# 12) Auditoría rápida
#######################################################################
- name: Audit {{ _name }}
  ansible.builtin.debug:
    msg:
      name: "{{ _name }}"
      endpoint: "{{ _endpoint }}"
      endpoint_id_resolved: "{{ _endpoint_id_resolved }}"
      exists_id: "{{ _existing_stack_id }}"
      is_git_based: "{{ _is_git_based | default('n/a') }}"
      must_recreate: "{{ _must_recreate | default('n/a') }}"
      create_repo_status: "{{ (_create_repo.status | default('n/a')) if _create_repo is defined else 'n/a' }}"
      create_string_status: "{{ (_create_string.status | default('n/a')) if _create_string is defined else 'n/a' }}"
      update_status: "{{ (_update.status | default('n/a')) if _update is defined else 'n/a' }}"
      redeploy_status: "{{ (_redeploy.status | default('n/a')) if _redeploy is defined else 'n/a' }}"
      recreate_repo_status: "{{ (_recreate_repo.status | default('n/a')) if _recreate_repo is defined else 'n/a' }}"
      recreate_string_status: "{{ (_recreate_string.status | default('n/a')) if _recreate_string is defined else 'n/a' }}"