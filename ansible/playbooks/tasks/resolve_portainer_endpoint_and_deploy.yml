# playbooks/tasks/resolve_portainer_endpoint_and_deploy.yml
---
# Este taskfile se incluye "per stack" con item que contiene:
# name, endpoint, repo_url, compose_path, git_ref, env (opcional), endpoint_id (opcional)
# Variables globales esperadas:
# - portainer_url_effective
# - portainer_api_token
# - portainer_validate_certs (bool, por defecto: false)
# - endpoints_by_name_map (dict: {alias_or_name: endpointId})
# - alias_map (dict opcional para alias de endpoints)
# - git_ssh_key_path (ruta a clave SSH del controlador; opcional pero requerida si repo usa git@)

- name: Normalize fields for {{ item.name }}
  vars:
    _env_default: []
  ansible.builtin.set_fact:
    _name: "{{ item.name }}"
    _endpoint: "{{ item.endpoint | default('') }}"
    _endpoint_id: "{{ item.endpoint_id | default('') }}"
    _repo_url: "{{ item.repo_url }}"
    _compose_path: "{{ item.compose_path }}"
    _git_ref: "{{ item.git_ref | default('main') }}"
    _env: "{{ item.env | default(_env_default) }}"

- name: Validate required fields for {{ _name }}
  ansible.builtin.assert:
    that:
      - _name | string | length > 0
      - _repo_url | string | length > 0
      - _compose_path | string | length > 0
      - _git_ref | string | length > 0
    fail_msg: >
      Faltan campos requeridos en stack {{ _name }}. Recibido:
      name='{{ _name }}', repo_url='{{ _repo_url }}',
      compose_path='{{ _compose_path }}', git_ref='{{ _git_ref }}'.

- name: Resolve endpointId for {{ _name }}
  ansible.builtin.set_fact:
    _resolved_endpoint_id: |
      {%- if (_endpoint_id | default('') | string | length) > 0 -%}
      {{ _endpoint_id }}
      {%- elif (_endpoint | default('') | string | length) > 0 -%}
      {%- set e = _endpoint -%}
      {%- set alias = (alias_map | default({})).get(e, e) -%}
      {{ (endpoints_by_name_map | default({})).get(alias, (endpoints_by_name_map | default({})).get(e, '')) }}
      {%- else -%}
      {{ (endpoints_by_name_map | default({})).get('local','') }}
      {%- endif -%}

- name: Fail if endpoint cannot be resolved for {{ _name }}
  ansible.builtin.assert:
    that:
      - _resolved_endpoint_id | string | length > 0
    fail_msg: >
      No fue posible resolver endpointId para el stack {{ _name }}.
      endpoint='{{ _endpoint }}', endpoint_id='{{ _endpoint_id }}'.

# -----------------------------
# LECTURA DE STACKS EXISTENTES
# -----------------------------
- name: Fetch stacks list
  ansible.builtin.uri:
    url: "{{ portainer_url_effective }}/api/stacks"
    method: GET
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    return_content: true
  register: _stacks_list
  changed_when: false

- name: Find existing stack id by name (exact match)
  ansible.builtin.set_fact:
    _existing_stack_id: >-
      {{
        (
          _stacks_list.json | selectattr('Name','equalto', _name) | list | first
        )['Id']
        if (_stacks_list.json | selectattr('Name','equalto', _name) | list | length) > 0
        else 0
      }}

# -------------------------------------------------------
# CREACIÓN: primero intentamos method=repository (POST)
# -------------------------------------------------------
- name: Try create stack {{ _name }} from repository
  when: (_existing_stack_id | int) == 0
  ansible.builtin.uri:
    url: >-
      {{ portainer_url_effective }}/api/stacks?type=2&method=repository&endpointId={{ _resolved_endpoint_id }}
    method: POST
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      name: "{{ _name }}"
      env: "{{ _env }}"
      repoURL: "{{ _repo_url }}"
      composeFilePathInRepo: "{{ _compose_path }}"
      repositoryReferenceName: "{{ _git_ref }}"
      repositoryAuthentication: false
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: [200, 201, 400, 403, 404, 405]
  register: _create_repo_attempt
  changed_when: "{{ _create_repo_attempt.status in [200,201] | bool }}"

- name: Decide fallback to method=string on create
  when: (_existing_stack_id | int) == 0
  ansible.builtin.set_fact:
    _must_create_via_string: >-
      {{
        _create_repo_attempt.status | default(0) in [400,403,404,405]
        or (_create_repo_attempt.status | default(500)) not in [200,201]
      }}

# -------------------------------------------------------------------
# FALLBACK: method=string -> clonar repo en controlador y enviar file
# -------------------------------------------------------------------
- name: Fail early if SSH repo without key configured (create fallback)
  when:
    - (_existing_stack_id | int) == 0
    - (_must_create_via_string | default(false))
    - _repo_url is search('^git@')
    - (git_ssh_key_path | default('')) == ''
  ansible.builtin.fail:
    msg: >
      El repo {{ _repo_url }} usa SSH y no definiste git_ssh_key_path.
      Configura una clave SSH en el controlador y pon git_ssh_key_path con su ruta.

- name: Clone repo for {{ _name }} (fallback create via string)
  when:
    - (_existing_stack_id | int) == 0
    - (_must_create_via_string | default(false))
  ansible.builtin.git:
    repo: "{{ _repo_url }}"
    version: "{{ _git_ref }}"
    dest: "/tmp/portainer_stack_{{ _name }}"
    accept_hostkey: yes
    key_file: "{{ git_ssh_key_path | default(omit) }}"
  delegate_to: localhost
  run_once: true

- name: Read compose file (create via string)
  when:
    - (_existing_stack_id | int) == 0
    - (_must_create_via_string | default(false))
  ansible.builtin.slurp:
    src: "/tmp/portainer_stack_{{ _name }}/{{ _compose_path }}"
  register: _compose_slurp_create
  delegate_to: localhost
  run_once: true

- name: Create stack {{ _name }} via method=string
  when:
    - (_existing_stack_id | int) == 0
    - (_must_create_via_string | default(false))
  ansible.builtin.uri:
    url: >-
      {{ portainer_url_effective }}/api/stacks?type=2&method=string&endpointId={{ _resolved_endpoint_id }}
    method: POST
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      Name: "{{ _name }}"
      Env: "{{ _env }}"
      StackFileContent: "{{ _compose_slurp_create.content | b64decode }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: [200,201]
  register: _create_string
  changed_when: true

# -----------------------------------
# ACTUALIZACIÓN DE STACK EXISTENTE
# -----------------------------------
# Intento 1: Si el stack es git-based, re-deploy
- name: Determine if existing stack {{ _name }} is git-based
  when: (_existing_stack_id | int) != 0
  ansible.builtin.set_fact:
    _existing_is_git: >-
      {{
        (
          (_stacks_list.json | selectattr('Id','equalto', _existing_stack_id | int) | list | first)
          .GitConfig is defined
        )
      }}

- name: Update git ref / file path on existing stack {{ _name }} (best effort)
  when:
    - (_existing_stack_id | int) != 0
    - (_existing_is_git | default(false))
  ansible.builtin.uri:
    url: "{{ portainer_url_effective }}/api/stacks/{{ _existing_stack_id }}"
    method: PUT
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      # Estos campos pueden variar por versión de Portainer; se intenta best-effort:
      RepositoryURL: "{{ _repo_url }}"
      ComposeFilePathInRepository: "{{ _compose_path }}"
      RepositoryReferenceName: "{{ _git_ref }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: [200, 204, 400, 404, 405]
  register: _update_git_cfg
  changed_when: "{{ _update_git_cfg.status in [200,204] | bool }}"

- name: Git redeploy existing stack {{ _name }}
  when:
    - (_existing_stack_id | int) != 0
    - (_existing_is_git | default(false))
  ansible.builtin.uri:
    url: "{{ portainer_url_effective }}/api/stacks/{{ _existing_stack_id }}/git/redeploy?endpointId={{ _resolved_endpoint_id }}"
    method: POST
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: [200, 204, 400, 404, 405]
  register: _redeploy_attempt
  changed_when: "{{ _redeploy_attempt.status in [200,204] | bool }}"

# Intento 2: Si no es git-based o el redeploy no aplica, recreamos via string
- name: Decide if we must recreate stack from repository (non-git or bad redeploy)
  when: (_existing_stack_id | int) != 0
  ansible.builtin.set_fact:
    _must_recreate_via_string: >-
      {{
        (not (_existing_is_git | default(false)))
        or (_redeploy_attempt is defined and (_redeploy_attempt.status | default(0)) in [400,404,405])
      }}

- name: Fail early if SSH repo without key configured (recreate fallback)
  when:
    - (_existing_stack_id | int) != 0
    - (_must_recreate_via_string | default(false))
    - _repo_url is search('^git@')
    - (git_ssh_key_path | default('')) == ''
  ansible.builtin.fail:
    msg: >
      El repo {{ _repo_url }} usa SSH y no definiste git_ssh_key_path.
      Configura una clave SSH en el controlador y pon git_ssh_key_path con su ruta.

- name: Clone repo for {{ _name }} (fallback recreate via string)
  when:
    - (_existing_stack_id | int) != 0
    - (_must_recreate_via_string | default(false))
  ansible.builtin.git:
    repo: "{{ _repo_url }}"
    version: "{{ _git_ref }}"
    dest: "/tmp/portainer_stack_{{ _name }}"
    accept_hostkey: yes
    key_file: "{{ git_ssh_key_path | default(omit) }}"
  delegate_to: localhost
  run_once: true

- name: Read compose file (recreate via string)
  when:
    - (_existing_stack_id | int) != 0
    - (_must_recreate_via_string | default(false))
  ansible.builtin.slurp:
    src: "/tmp/portainer_stack_{{ _name }}/{{ _compose_path }}"
  register: _compose_slurp_update
  delegate_to: localhost
  run_once: true

- name: Delete stack {{ _name }} (prior to recreate via string)
  when:
    - (_existing_stack_id | int) != 0
    - (_must_recreate_via_string | default(false))
  ansible.builtin.uri:
    url: "{{ portainer_url_effective }}/api/stacks/{{ _existing_stack_id }}?endpointId={{ _resolved_endpoint_id }}"
    method: DELETE
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: [200,204,404]
  register: _delete_existing
  changed_when: "{{ _delete_existing.status in [200,204] | bool }}"

- name: Recreate stack {{ _name }} via method=string
  when:
    - (_existing_stack_id | int) != 0
    - (_must_recreate_via_string | default(false))
  ansible.builtin.uri:
    url: >-
      {{ portainer_url_effective }}/api/stacks?type=2&method=string&endpointId={{ _resolved_endpoint_id }}
    method: POST
    headers:
      Authorization: "Bearer {{ portainer_api_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      Name: "{{ _name }}"
      Env: "{{ _env }}"
      StackFileContent: "{{ _compose_slurp_update.content | b64decode }}"
    validate_certs: "{{ portainer_validate_certs | default(false) }}"
    status_code: [200,201]
  register: _recreate_string
  changed_when: true