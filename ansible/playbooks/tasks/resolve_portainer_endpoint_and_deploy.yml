# playbooks/tasks/resolve_portainer_endpoint_and_deploy.yml
---
# ----- Normalización y validaciones -----
- name: Normalize fields for stack {{ st.name }}
  ansible.builtin.set_fact:
    _file_path: "{{ st.file_path | default(st.compose_path | default('')) }}"
    _git_ref: "{{ st.git_ref | default('main') }}"
    _env_vars: "{{ st.env | default([]) }}"
    _endpoint: "{{ st.endpoint | default('') }}"
    _endpoint_id: "{{ st.endpoint_id | default('') }}"
    _prune: "{{ st.prune | default(true) }}"

- name: Validate required fields for stack {{ st.name }}
  ansible.builtin.assert:
    that:
      - st.name is defined
      - st.repo_url is defined
      - _file_path | length > 0
    fail_msg: "Faltan campos en stack {{ st | to_nice_json }}"

- name: Resolve endpointId for {{ st.name }}
  ansible.builtin.set_fact:
    _endpoint_id_resolved: >-
      {%- if _endpoint_id | string | length > 0 -%}
        {{ _endpoint_id }}
      {%- elif _endpoint | string | length > 0 -%}
        {%- set e = _endpoint -%}
        {%- set alias = alias_map.get(e, e) -%}
        {{ endpoints_by_name_map.get(alias) | default(endpoints_by_name_map.get(e), true) | default('', true) }}
      {%- else -%}
        {{ endpoints_by_name_map.get('local') | default('', true) }}
      {%- endif -%}

- name: Fail if endpoint cannot be resolved for {{ st.name }}
  ansible.builtin.assert:
    that: _endpoint_id_resolved | string | length > 0
    fail_msg: "No se pudo resolver endpointId para stack {{ st.name }} (endpoint='{{ _endpoint }}')."

# ----- Descubrir stack existente -----
- name: Fetch stacks list
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks"
    method: GET
    headers:
      X-API-Key: "{{ p_api_token }}"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200
    return_content: true
  register: _stacks

- name: Find existing stack id by name (exact match)
  ansible.builtin.set_fact:
    _existing_stack: "{{ (_stacks.json | selectattr('Name','equalto', st.name) | list | first) | default(None) }}"
    _existing_stack_id: "{{ ((_stacks.json | selectattr('Name','equalto', st.name) | list | first).Id) | default(None) }}"

# ----- Crear si NO existe -----
- name: Create stack {{ st.name }} from repository (compose/standalone)
  when: _existing_stack_id is not defined
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/create?type=2&method=repository&endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 201
    body_format: json
    body:
      Name: "{{ st.name }}"
      RepositoryURL: "{{ st.repo_url }}"
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFilePathInRepository: "{{ _file_path }}"
      Env: "{{ _env_vars }}"
      Prune: "{{ _prune }}"
  register: _create

# ----- Si existe, decidir si soporta Git -----
- name: Determine if existing stack {{ st.name }} is git-based
  when: _existing_stack_id is defined
  ansible.builtin.set_fact:
    _is_git_based: >-
      {{
        (_existing_stack is defined) and (
          (_existing_stack.GitConfig is defined) or
          (_existing_stack.RepositoryURL is defined) or
          (_existing_stack.GitRepository is defined)
        )
      }}

# ----- Actualizar metadatos (por si ya es git-based) -----
- name: Update git ref / file path on existing stack {{ st.name }} (best effort)
  when: _existing_stack_id is defined and _is_git_based
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/{{ _existing_stack_id }}"
    method: PUT
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200
    body_format: json
    body:
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFilePathInRepository: "{{ _file_path }}"
  register: _update
  failed_when: false

# ----- Redeploy por Git si es git-based -----
- name: Git redeploy existing stack {{ st.name }}
  when: _existing_stack_id is defined and _is_git_based
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/{{ _existing_stack_id }}/git/redeploy?endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    # Algunos Portainer devuelven 204; aceptamos 200/204
    status_code: 200, 204
    body_format: json
    body:
      Prune: "{{ _prune }}"
      PullImage: true
      Env: "{{ _env_vars }}"
  register: _redeploy
  failed_when: false

# ----- Fallback: borrar y recrear si NO es git-based o si el redeploy devolvió 405 -----
- name: Decide if we must recreate stack from repository
  when: _existing_stack_id is defined
  ansible.builtin.set_fact:
    _must_recreate: >-
      {{
        (not _is_git_based)
        or
        (_redeploy is defined and (_redeploy.status | default(0)) == 405)
      }}

- name: Delete non-git stack {{ st.name }} to recreate from repository
  when: _existing_stack_id is defined and _must_recreate
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/{{ _existing_stack_id }}?endpointId={{ _endpoint_id_resolved }}"
    method: DELETE
    headers:
      X-API-Key: "{{ p_api_token }}"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 204
  register: _deleted

- name: Recreate stack {{ st.name }} from repository (after delete)
  when: _existing_stack_id is defined and _must_recreate
  ansible.builtin.uri:
    url: "{{ p_url }}/api/stacks/create?type=2&method=repository&endpointId={{ _endpoint_id_resolved }}"
    method: POST
    headers:
      X-API-Key: "{{ p_api_token }}"
      Content-Type: "application/json"
    validate_certs: "{{ p_validate_certs }}"
    status_code: 200, 201
    body_format: json
    body:
      Name: "{{ st.name }}"
      RepositoryURL: "{{ st.repo_url }}"
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFilePathInRepository: "{{ _file_path }}"
      Env: "{{ _env_vars }}"
      Prune: "{{ _prune }}"
  register: _recreate