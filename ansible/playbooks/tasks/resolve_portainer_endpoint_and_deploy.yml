---
# Tarea incluída por:
# - name: Resolve endpoint and deploy (per stack)
#   include_tasks: tasks/resolve_portainer_endpoint_and_deploy.yml
#   loop: "{{ stacks_effective | list if stacks_effective is sequence else (stacks_effective.keys() | list) }}"
#   loop_control: { loop_var: item }

#######################################################################
# 0) Resolver el objeto de stack para este item (robusto y sin "unhashable")
#######################################################################
- name: Normalizar colecciones de stacks (mapa y lista)
  set_fact:
    _stacks_map: "{{ (stacks_effective | default({})) if (stacks_effective is mapping) else {} }}"
    _stacks_seq: "{{ (stacks_effective | default([]))  if (stacks_effective is sequence) else [] }}"

# Si item viene como dict, extraemos su nombre; si es string, lo usamos tal cual
- name: Derivar _item_name y _item_obj
  set_fact:
    _item_obj: "{{ item if (item is mapping) else {} }}"
    _item_name: >-
      {{
        (item.name | default(item.Name) | default(''))
        if (item is mapping)
        else (item | string)
      }}

- name: Resolver coincidencia por nombre en la lista (si aplica)
  set_fact:
    _seq_match: >-
      {{
        (_stacks_seq
          | selectattr('name','defined')
          | selectattr('name','equalto', _item_name)
          | list)
        if (_stacks_seq | length) > 0 and (_item_name | length) > 0 else []
      }}

# Fuente de la verdad (_it):
# 1) Si item ya es un dict con nombre, úsalo.
# 2) Si existe en el mapa por clave _item_name, úsalo.
# 3) Si aparece en la lista, toma el primero.
# 4) Si nada de lo anterior, deja {} y la aserción siguiente lo explicará.
- name: Resolve current stack object to _it
  set_fact:
    _it: >-
      {{
        _item_obj
          if (_item_obj is mapping and (_item_obj.name | default('')) | length > 0)
        else
          (
            _stacks_map[_item_name]
              if (_stacks_map is mapping and (_item_name | length > 0) and (_item_name in _stacks_map.keys()))
            else
              (
                _seq_match[0]
                  if (_seq_match | length) > 0
                else
                  {}
              )
          )
      }}

- name: Ensure _it is a valid stack object
  assert:
    that:
      - _it is mapping
      - (_it.name | default('')) | length > 0
    success_msg: "All assertions passed"
    fail_msg: >
      No encontré definición para el item '{{ _item_name }}' en 'stacks_effective'.
      Define un objeto con 'name' en stacks_effective (mapa o lista).
      Pistas:
      - keys del mapa: {{ _stacks_map.keys() | default([]) }}
      - nombres en la lista: {{ (_stacks_seq | map(attribute='name') | list) | default([]) }}

#######################################################################
# 1) Autenticación y normalización de campos
#######################################################################
# ⚠️ Separado en dos tareas para no usar variables recién definidas en el mismo set_fact
- name: Definir modo de auth y token
  set_fact:
    _use_api_key: "{{ (portainer_use_api_key | default(true)) | bool }}"
    _token: "{{ portainer_api_token | default('') }}"

- name: Build Portainer auth headers
  set_fact:
    _headers: >-
      {{
        {'X-API-Key': _token}
        if _use_api_key
        else {'Authorization': 'Bearer ' + _token}
      }}

- name: Validate token presence
  assert:
    that:
      - _token | length > 0
    success_msg: "All assertions passed"
    fail_msg: "portainer_api_token ausente/vacío."

- name: Normalize fields
  set_fact:
    _name: "{{ _it.name }}"
    _endpoint: "{{ _it.endpoint | default('') }}"
    _repo_url: "{{ _it.repo_url | default('') }}"
    _compose_path: "{{ _it.compose_path | default('docker-compose.yml') }}"
    _git_ref: "{{ _it.git_ref | default('main') }}"
    _env: "{{ _it.env | default([]) }}"

#######################################################################
# 2) Resolver endpointId a partir de mapas/listas disponibles
#######################################################################
# Preferir mapa interno si existe; si no, construirlo desde endpoints_list.
- name: Construir mapa de endpoints por nombre si no existe
  set_fact:
    _endpoints_by_name_map: >-
      {{
        endpoints_by_name_map
          if (endpoints_by_name_map is mapping)
        else
          (
            _endpoints_by_name_map
              if (_endpoints_by_name_map is mapping)
            else
              (
                dict( (endpoints_list | default([])) | map(attribute='Name') | zip((endpoints_list | default([])) | map(attribute='Id')) )
              )
          )
      }}

- name: Resolver endpointId
  set_fact:
    _endpoint_id: >-
      {{
        (
          (_it.endpoint_id | default('')) | string
          if (_it.endpoint_id | default('') | string | length > 0)
          else
            (
              _endpoints_by_name_map.get(_endpoint)
                if (_endpoint | length > 0)
              else
                (
                  _endpoints_by_name_map.get('local') | default('')
                )
            )
        )
      }}

- name: Fail if endpoint cannot be resolved
  assert:
    that:
      - _endpoint_id | string | length > 0
    success_msg: "All assertions passed"
    fail_msg: "No pude resolver endpointId para '{{ _name }}' (endpoint='{{ _endpoint }}')."

#######################################################################
# 3) Leer stacks existentes y buscar colisión exacta por nombre
#######################################################################
- name: Fetch stacks list
  uri:
    url: "{{ portainer_url_effective | mandatory }}/api/stacks"
    method: GET
    headers: "{{ _headers }}"
    validate_certs: false
    return_content: true
    status_code: 200
  register: _stacks_resp

# Si el servidor devolviera 401 con JWT mal formateado, se puede usar esta task extra para fallar explícito.
- name: Fail if unauthorized (bad/expired token or wrong header type)
  when: _stacks_resp.status == 401
  fail:
    msg: "Portainer devolvió 401 Unauthorized. Verifica: - Si usas API Key, define portainer_use_api_key: true - Si usas JWT, que no esté expirado (re-genera). Detalle: {{ _stacks_resp.json | default(_stacks_resp.content) }}"

- name: Find existing stack id by name (exact match)
  set_fact:
    _existing_stack: >-
      {{
        (_stacks_resp.json | default([]))
          | selectattr('Name','equalto', _name)
          | selectattr('EndpointId','equalto', (_endpoint_id | int))
          | list
      }}
    _existing_id: >-
      {{
        (_existing_stack[0].Id | default(''))
        if (_existing_stack | length) > 0
        else ''
      }}

#######################################################################
# 4) Crear stack (preferir método repository; fallback a string)
#    Soporta endpoints "nuevos" (/create/compose/...) y fallback "legacy".
#######################################################################
- name: Definir URLs de creación (hybrid + legacy)
  set_fact:
    _create_urls:
      repo_new:   "{{ portainer_url_effective }}/api/stacks/create/compose/repository?endpointId={{ _endpoint_id }}"
      string_new: "{{ portainer_url_effective }}/api/stacks/create/compose/string?endpointId={{ _endpoint_id }}"
      repo_legacy:   "{{ portainer_url_effective }}/api/stacks?type=2&method=repository&endpointId={{ _endpoint_id }}"
      string_legacy: "{{ portainer_url_effective }}/api/stacks?type=2&method=string&endpointId={{ _endpoint_id }}"

- name: Try create stack {{ _name }} from repository (NEW path)
  when:
    - (_existing_id | string) == ''
    - _repo_url | length > 0
  uri:
    url: "{{ _create_urls.repo_new }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409, 400, 405, 404]
    body_format: json
    body:
      name: "{{ _name }}"
      repositoryURL: "{{ _repo_url }}"
      composeFilePathInRepository: "{{ _compose_path }}"
      repositoryReferenceName: "{{ _git_ref }}"
      env: "{{ _env }}"
      prune: true
      pullImage: true
  register: _create_repo_new

- name: Try create stack {{ _name }} from repository (LEGACY path if 405/404/400)
  when:
    - (_existing_id | string) == ''
    - _repo_url | length > 0
    - _create_repo_new is defined
    - _create_repo_new.status in [405, 404, 400]
  uri:
    url: "{{ _create_urls.repo_legacy }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409]
    body_format: json
    body:
      name: "{{ _name }}"
      repositoryURL: "{{ _repo_url }}"
      composeFilePathInRepository: "{{ _compose_path }}"
      repositoryReferenceName: "{{ _git_ref }}"
      env: "{{ _env }}"
      prune: true
      pullImage: true
  register: _create_repo_legacy

#######################################################################
# 5) Fallback a creación por STRING si:
#    - no hay repo_url, o
#    - la creación por repo falló y no existe stack aún.
#######################################################################
- name: Decidir si debemos intentar creación por string
  set_fact:
    _must_string: >-
      {{
        (
          (_existing_id | string) == '' and
          (
            _repo_url | length == 0 or
            (
              _create_repo_new is defined and _create_repo_new.status not in [200,201,409]
            ) or
            (
              _create_repo_new is not defined and
              _create_repo_legacy is defined and _create_repo_legacy.status not in [200,201,409]
            )
          )
        )
      }}

- name: Crear dir temporal único para {{ _name }} (fallback)
  when: _must_string
  tempfile:
    state: directory
    prefix: "ans_port_{{ _name }}_"
  register: _tmpdir
  delegate_to: localhost

- name: Clonar repo (si hay) o preparar ruta (fallback create via string, idempotente)
  when: _must_string and (_repo_url | length) > 0
  git:
    repo: "{{ _repo_url }}"
    dest: "{{ _tmpdir.path }}/repo"
    version: "{{ _git_ref }}"
    accept_hostkey: yes
  delegate_to: localhost

- name: Leer contenido del compose (fallback)
  when: _must_string
  slurp:
    src: >-
      {{
        (_tmpdir.path + '/repo/' + _compose_path)
          if (_repo_url | length) > 0
        else
          (_compose_path)
      }}
  register: _compose_slurp
  delegate_to: localhost

- name: Crear stack {{ _name }} via method=string (NEW path)
  when: _must_string
  uri:
    url: "{{ _create_urls.string_new }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409, 400, 405, 404]
    body_format: json
    body:
      name: "{{ _name }}"
      stackFileContent: "{{ (_compose_slurp.content | b64decode) }}"
      env: "{{ _env }}"
      prune: true
  register: _create_string_new

- name: Crear stack {{ _name }} via method=string (LEGACY path si 405/404/400)
  when: _must_string and _create_string_new is defined and _create_string_new.status in [405, 404, 400]
  uri:
    url: "{{ _create_urls.string_legacy }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409]
    body_format: json
    body:
      name: "{{ _name }}"
      stackFileContent: "{{ (_compose_slurp.content | b64decode) }}"
      env: "{{ _env }}"
      prune: true
  register: _create_string_legacy

#######################################################################
# 6) Resultado (solo auditoría)
#######################################################################
- name: Resultado de creación/auditoría para {{ _name }}
  debug:
    msg:
      existing_id: "{{ _existing_id | default('') }}"
      repo_new_status: "{{ _create_repo_new.status if _create_repo_new is defined else 'n/a' }}"
      repo_legacy_status: "{{ _create_repo_legacy.status if _create_repo_legacy is defined else 'n/a' }}"
      string_new_status: "{{ _create_string_new.status if _create_string_new is defined else 'n/a' }}"
      string_legacy_status: "{{ _create_string_legacy.status if _create_string_legacy is defined else 'n/a' }}"