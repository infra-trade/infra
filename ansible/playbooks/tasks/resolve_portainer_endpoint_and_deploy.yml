---
#######################################################################
# 0) Resolver el objeto de stack para este item (robusto)
#######################################################################
- name: Normalizar colecciones de stacks (mapa y lista)
  set_fact:
    _stacks_map: "{{ (stacks_effective | default({})) if (stacks_effective is mapping) else {} }}"
    _stacks_seq: "{{ (stacks_effective | default([]))  if (stacks_effective is sequence) else [] }}"

- name: Derivar _item_name y _item_obj
  set_fact:
    _item_obj: "{{ item if (item is mapping) else {} }}"
    _item_name: >-
      {{
        (item.name | default(item.Name) | default(''))
        if (item is mapping)
        else (item | string)
      }}

- name: Resolver coincidencia por nombre en la lista (si aplica)
  set_fact:
    _seq_match: >-
      {{
        (_stacks_seq
          | selectattr('name','defined')
          | selectattr('name','equalto', _item_name)
          | list)
        if (_stacks_seq | length) > 0 and (_item_name | length) > 0 else []
      }}

- name: Resolve current stack object to _it
  set_fact:
    _it: >-
      {{
        _item_obj
          if (_item_obj is mapping and (_item_obj.name | default('')) | length > 0)
        else
          (
            _stacks_map[_item_name]
              if (_stacks_map is mapping and (_item_name | length > 0) and (_item_name in _stacks_map.keys()))
            else
              (
                _seq_match[0]
                  if (_seq_match | length) > 0
                else
                  {}
              )
          )
      }}

- name: Ensure _it is a valid stack object
  assert:
    that:
      - _it is mapping
      - (_it.name | default('')) | length > 0
    success_msg: "All assertions passed"
    fail_msg: >
      No encontré definición para el item '{{ _item_name }}' en 'stacks_effective'.

#######################################################################
# 1) Autenticación y normalización de campos
#######################################################################
- name: Definir modo de auth y token
  set_fact:
    _use_api_key: "{{ (portainer_use_api_key | default(true)) | bool }}"
    _token: "{{ portainer_api_token | default('') }}"

- name: Build Portainer auth headers
  set_fact:
    _headers: >-
      {{
        {'X-API-Key': _token}
        if _use_api_key
        else {'Authorization': 'Bearer ' + _token}
      }}

- name: Validate token presence
  assert:
    that: [ "_token | length > 0" ]
    success_msg: "All assertions passed"
    fail_msg: "portainer_api_token ausente/vacío."

- name: Normalize fields
  set_fact:
    _name: "{{ _it.name }}"
    _endpoint: "{{ _it.endpoint | default('') }}"
    _repo_url: "{{ _it.repo_url | default('') }}"
    _compose_path: "{{ _it.compose_path | default('docker-compose.yml') }}"
    _git_ref: "{{ _it.git_ref | default('main') }}"
    _env: "{{ _it.env | default([]) }}"

#######################################################################
# 2) Resolver endpointId con alias dinámicos
#######################################################################
- name: Construir mapa de endpoints por nombre si no existe
  set_fact:
    _endpoints_by_name_map: >-
      {{
        endpoints_by_name_map
          if (endpoints_by_name_map is mapping)
        else
          dict( (endpoints_list | default([])) | map(attribute='Name') | zip((endpoints_list | default([])) | map(attribute='Id')) )
      }}

# >>> FIX: separar en 2 tasks para que _core_alias_map exista antes de usarlo <<<
- name: Construir alias base -core (base -> nombre real)
  set_fact:
    _core_alias_map: >-
      {{
        dict(
          (
            (endpoints_list | default([])) | map(attribute='Name') | list
          )
          | map('regex_replace', '-core$', '')
          | list
          | zip( (endpoints_list | default([])) | map(attribute='Name') | list )
        )
      }}

- name: Fusionar alias dinámicos y del usuario
  set_fact:
    _alias_map: >-
      {{
        {'mon': 'local'}
        | combine(_core_alias_map | default({}))
        | combine(alias_map | default({}))
      }}

- name: Resolver endpointId
  set_fact:
    _endpoint_resolved_name: >-
      {{
        (_alias_map.get(_endpoint) if (_endpoint | length > 0) else 'local')
      }}
    _endpoint_id: >-
      {{
        _endpoints_by_name_map.get(_endpoint_resolved_name)
        | default(_endpoints_by_name_map.get(_endpoint))
        | default(_endpoints_by_name_map.get('local'))
        | default('')
      }}

- name: Fail if endpoint cannot be resolved
  assert:
    that:
      - _endpoint_id | string | length > 0
    success_msg: "All assertions passed"
    fail_msg: "No pude resolver endpointId para '{{ _name }}' (endpoint='{{ _endpoint }}'). Alias usado='{{ _endpoint_resolved_name }}'. Endpoints conocidos={{ _endpoints_by_name_map.keys() | list }}"

#######################################################################
# 3) Leer stacks existentes
#######################################################################
- name: Fetch stacks list
  uri:
    url: "{{ portainer_url_effective | mandatory }}/api/stacks"
    method: GET
    headers: "{{ _headers }}"
    validate_certs: false
    return_content: true
    status_code: 200
  register: _stacks_resp

- name: Find existing stack id by name (exact match)
  set_fact:
    _existing_stack: >-
      {{
        (_stacks_resp.json | default([]))
          | selectattr('Name','equalto', _name)
          | selectattr('EndpointId','equalto', (_endpoint_id | int))
          | list
      }}
    _existing_id: >-
      {{
        (_existing_stack[0].Id | default(''))
        if (_existing_stack | length) > 0
        else ''
      }}

#######################################################################
# 4) Crear stack (repo primero; fallback string) — soporta NEW y LEGACY
#######################################################################
- name: Definir URLs de creación (hybrid + legacy)
  set_fact:
    _create_urls:
      repo_new:   "{{ portainer_url_effective }}/api/stacks/create/compose/repository?endpointId={{ _endpoint_id }}"
      string_new: "{{ portainer_url_effective }}/api/stacks/create/compose/string?endpointId={{ _endpoint_id }}"
      repo_legacy:   "{{ portainer_url_effective }}/api/stacks?type=2&method=repository&endpointId={{ _endpoint_id }}"
      string_legacy: "{{ portainer_url_effective }}/api/stacks?type=2&method=string&endpointId={{ _endpoint_id }}"

- name: Try create stack {{ _name }} from repository (NEW path)
  when:
    - (_existing_id | string) == ''
    - _repo_url | length > 0
  uri:
    url: "{{ _create_urls.repo_new }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409, 400, 405, 404]
    body_format: json
    body:
      name: "{{ _name }}"
      repositoryURL: "{{ _repo_url }}"
      composeFilePathInRepository: "{{ _compose_path }}"
      repositoryReferenceName: "{{ _git_ref }}"
      env: "{{ _env }}"
      prune: true
      pullImage: true
  register: _create_repo_new

- name: Try create stack {{ _name }} from repository (LEGACY path si 405/404/400)
  when:
    - (_existing_id | string) == ''
    - _repo_url | length > 0
    - _create_repo_new is defined
    - _create_repo_new.status in [405, 404, 400]
  uri:
    url: "{{ _create_urls.repo_legacy }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409]
    body_format: json
    body:
      name: "{{ _name }}"
      repositoryURL: "{{ _repo_url }}"
      composeFilePathInRepository: "{{ _compose_path }}"
      repositoryReferenceName: "{{ _git_ref }}"
      env: "{{ _env }}"
      prune: true
      pullImage: true
  register: _create_repo_legacy

#######################################################################
# 5) Fallback a creación por STRING si aplica
#######################################################################
- name: Decidir si debemos intentar creación por string
  set_fact:
    _must_string: >-
      {{
        (
          (_existing_id | string) == '' and
          (
            _repo_url | length == 0 or
            (
              _create_repo_new is defined and _create_repo_new.status not in [200,201,409]
            ) or
            (
              _create_repo_new is not defined and
              _create_repo_legacy is defined and _create_repo_legacy.status not in [200,201,409]
            )
          )
        )
      }}

- name: Crear dir temporal único para {{ _name }} (fallback)
  when: _must_string
  tempfile:
    state: directory
    prefix: "ans_port_{{ _name }}_"
  register: _tmpdir
  delegate_to: localhost

- name: Clonar repo (si hay) (fallback create via string)
  when: _must_string and (_repo_url | length) > 0
  git:
    repo: "{{ _repo_url }}"
    dest: "{{ _tmpdir.path }}/repo"
    version: "{{ _git_ref }}"
    accept_hostkey: yes
  delegate_to: localhost

- name: Leer contenido del compose (fallback)
  when: _must_string
  slurp:
    src: >-
      {{
        (_tmpdir.path + '/repo/' + _compose_path)
          if (_repo_url | length) > 0
        else
          (_compose_path)
      }}
  register: _compose_slurp
  delegate_to: localhost

- name: Crear stack {{ _name }} via method=string (NEW path)
  when: _must_string
  uri:
    url: "{{ _create_urls.string_new }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409, 400, 405, 404]
    body_format: json
    body:
      name: "{{ _name }}"
      stackFileContent: "{{ (_compose_slurp.content | b64decode) }}"
      env: "{{ _env }}"
      prune: true
  register: _create_string_new

- name: Crear stack {{ _name }} via method=string (LEGACY path si 405/404/400)
  when: _must_string and _create_string_new is defined and _create_string_new.status in [405, 404, 400]
  uri:
    url: "{{ _create_urls.string_legacy }}"
    method: POST
    headers: "{{ _headers }}"
    validate_certs: false
    status_code: [200, 201, 409]
    body_format: json
    body:
      name: "{{ _name }}"
      stackFileContent: "{{ (_compose_slurp.content | b64decode) }}"
      env: "{{ _env }}"
      prune: true
  register: _create_string_legacy

#######################################################################
# 6) Auditoría final
#######################################################################
- name: Resultado de creación/auditoría para {{ _name }}
  debug:
    msg:
      endpoint_requested: "{{ _endpoint }}"
      endpoint_alias_used: "{{ _endpoint_resolved_name }}"
      endpoint_id: "{{ _endpoint_id }}"
      existing_id: "{{ _existing_id | default('') }}"
      repo_new_status: "{{ _create_repo_new.status if _create_repo_new is defined else 'n/a' }}"
      repo_legacy_status: "{{ _create_repo_legacy.status if _create_repo_legacy is defined else 'n/a' }}"
      string_new_status: "{{ _create_string_new.status if _create_string_new is defined else 'n/a' }}"
      string_legacy_status: "{{ _create_string_legacy.status if _create_string_legacy is defined else 'n/a' }}"