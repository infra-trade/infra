---
# Este task-file se incluye con "loop: stacks_effective" (variable 'item' disponible)

- name: Resolve current stack object to _it
  set_fact:
    _it: "{{ item }}"

- name: Ensure _it is a valid stack object
  assert:
    that:
      - _it is mapping
    fail_msg: "El elemento del loop no es un dict de stack: {{ _it | to_nice_yaml }}"

# =========================
# AUTENTICACIÓN / HEADERS
# =========================
- name: Build Portainer auth headers
  set_fact:
    _portainer_auth_headers: >-
      {{
        ({'X-API-Key': portainer_api_token})
        if (portainer_use_api_key_effective | default(false) | bool)
        else ({'Authorization': 'Bearer ' ~ portainer_api_token})
      }}

# (Opcional) Debug para verificar qué cabeceras se enviarán
# - name: DEBUG - Ver headers que se enviarán
#   debug:
#     var: _portainer_auth_headers

- name: Validate token presence
  assert:
    that:
      - portainer_api_token | string | length > 0
    fail_msg: "portainer_api_token vacío (se requiere API Key o JWT)"

# =========================
# NORMALIZACIÓN / VALIDACIÓN
# =========================
- name: Normalize fields
  set_fact:
    _name: "{{ _it.name }}"
    _endpoint: "{{ _it.endpoint | default('') }}"
    _endpoint_id: "{{ _it.endpoint_id | default('') }}"
    _repo_url: "{{ _it.repo_url }}"
    _compose_path: "{{ _it.compose_path }}"
    _git_ref: "{{ _it.git_ref | default('main') }}"
    _env: "{{ _it.env | default([]) }}"
    _method: "{{ _it.method | default('repository') }}"   # repository|string

- name: Validate required fields
  assert:
    that:
      - _name | string | length > 0
      - (_endpoint | string | length > 0) or (_endpoint_id | string | length > 0)
      - _repo_url | string | length > 0
      - _compose_path | string | length > 0
    fail_msg: "Campos requeridos faltantes en stack {{ _it | to_nice_yaml }}"

# =========================
# RESOLVER endpointId
# =========================
- name: Resolve endpointId
  set_fact:
    _endpoint_resolved_id: >-
      {%- if (_endpoint_id | string | length) > 0 -%}
        {{ _endpoint_id }}
      {%- elif (_endpoint | string | length) > 0 -%}
        {%- set e = _endpoint -%}
        {%- set alias = (alias_map | default({})).get(e, e) -%}
        {{ (endpoints_by_name_map | default({})).get(alias) | default((endpoints_by_name_map | default({})).get(e, '')) }}
      {%- else -%}
        {{ (endpoints_by_name_map | default({})).get('local','') }}
      {%- endif -%}

- name: Fail if endpoint cannot be resolved
  assert:
    that:
      - _endpoint_resolved_id | string | length > 0
    fail_msg: "No pude resolver endpointId para endpoint '{{ _endpoint }}' (alias='{{ (alias_map|default({})).get(_endpoint,_endpoint) }}'). Mapa: {{ endpoints_by_name_map }}"

# =========================
# LISTAR STACKS (usa API Key si está activada)
# =========================
- name: Fetch stacks list
  uri:
    url: "{{ portainer_base_url }}/api/stacks"
    method: GET
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    return_content: yes
    status_code: 200
  register: _stacks_list

# Defensa explícita ante 401: si esto fallara, capturaría Unauthorized con mensaje guía
- name: Fail if unauthorized (bad/expired token or wrong header type)
  fail:
    msg: "Portainer devolvió 401 Unauthorized. Verifica: - Si usas API Key, define portainer_use_api_key: true - Si usas JWT, que no esté expirado (re-genera). Detalle: {{ _stacks_list.json | default(_stacks_list.content) }}"
  when: _stacks_list.status | default(200) == 401

# =========================
# BUSCAR STACK EXISTENTE
# =========================
- name: Find existing stack id by name (exact match)
  set_fact:
    _existing_stack_id: >-
      {{
        (_stacks_list.json | default([]))
          | selectattr('Name', 'equalto', _name)
          | map(attribute='Id')
          | first | default('')
      }}

# =========================
# CREAR / ACTUALIZAR
# =========================

# Intento de CREATE vía method=repository (Git), que es el camino ideal
- name: Try create stack {{ _name }} from repository
  uri:
    url: "{{ portainer_base_url }}/api/stacks?type=2&method=repository&endpointId={{ _endpoint_resolved_id }}"
    method: POST
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    body_format: json
    body:
      Name: "{{ _name }}"
      StackFilePath: "{{ _compose_path }}"
      RepositoryURL: "{{ _repo_url }}"
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFormat: 2
      # Env (si fuera necesario pasarlas)
      Env: "{{ _env }}"
    status_code: [200, 201, 409, 405]
  register: _create_try
  when: _existing_stack_id | string | length == 0

- name: Decide fallback to method=string on create
  set_fact:
    _must_fallback_string: "{{ (_create_try.status | default(0)) == 405 }}"
  when: _existing_stack_id | string | length == 0

# Fallback: si el Portainer no permite repo directo (405), clonamos local y mandamos el docker-compose como string
# OJO: esto requiere acceso al repo (tu caso usaba SSH; si no hay llave en el controlador, fallará).
- name: Clone repo for {{ _name }} (fallback create via string)
  delegate_to: localhost
  become: false
  git:
    repo: "{{ _repo_url }}"
    dest: "/tmp/ans_port_{{ _name }}"
    version: "{{ _git_ref }}"
    accept_hostkey: true
  when:
    - _existing_stack_id | string | length == 0
    - _must_fallback_string

- name: Read compose file content (fallback)
  delegate_to: localhost
  become: false
  slurp:
    src: "/tmp/ans_port_{{ _name }}/{{ _compose_path }}"
  register: _compose_slurp
  when:
    - _existing_stack_id | string | length == 0
    - _must_fallback_string

- name: Create stack {{ _name }} via method=string
  uri:
    url: "{{ portainer_base_url }}/api/stacks?type=2&method=string&endpointId={{ _endpoint_resolved_id }}"
    method: POST
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    body_format: json
    body:
      Name: "{{ _name }}"
      StackFileContent: "{{ (_compose_slurp.content | b64decode) }}"
      ComposeFormat: 2
      Env: "{{ _env }}"
    status_code: [200, 201, 409]
  register: _create_string
  when:
    - _existing_stack_id | string | length == 0
    - _must_fallback_string

# =========================
# UPDATE (si ya existe)
# =========================

# Si existe, intentamos actualizar su referencia git y/o hacer redeploy
- name: Update git ref / file path on existing stack {{ _name }} (best effort)
  uri:
    url: "{{ portainer_base_url }}/api/stacks/{{ _existing_stack_id }}"
    method: PUT
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    body_format: json
    body:
      # Solo aplica para stacks git-based; si no lo es, Portainer ignora/ falla benigno.
      RepositoryReferenceName: "{{ _git_ref }}"
      StackFilePath: "{{ _compose_path }}"
    status_code: [200, 204, 400, 404]
  register: _update_existing
  when: _existing_stack_id | string | length > 0

# Para stacks git-based modernos, el endpoint de redeploy suele ser (Portainer CE 2.19+):
# POST /api/stacks/{id}/git/redeploy?endpointId={endpointId}
- name: Git redeploy existing stack {{ _name }}
  uri:
    url: "{{ portainer_base_url }}/api/stacks/{{ _existing_stack_id }}/git/redeploy?endpointId={{ _endpoint_resolved_id }}"
    method: POST
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    status_code: [200, 204, 400, 404, 405]
  register: _git_redeploy
  when: _existing_stack_id | string | length > 0

# Si el stack no es git-based (o Portainer responde 405), puedes decidir recrearlo:
- name: Decide if we must recreate stack from repository
  set_fact:
    _must_recreate_from_repo: "{{ (_git_redeploy.status | default(0)) == 405 }}"
  when: _existing_stack_id | string | length > 0

# Borrado del stack no-git para recrear (ruta correcta de DELETE es /api/stacks/{id})
- name: Delete non-git stack {{ _name }} to recreate from repository
  uri:
    url: "{{ portainer_base_url }}/api/stacks/{{ _existing_stack_id }}?endpointId={{ _endpoint_resolved_id }}"
    method: DELETE
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    status_code: [200, 204, 404]
  register: _delete_existing
  when:
    - _existing_stack_id | string | length > 0
    - _must_recreate_from_repo

# Reintenta creación desde repo si se borró
- name: Re-create stack {{ _name }} from repository (after delete)
  uri:
    url: "{{ portainer_base_url }}/api/stacks?type=2&method=repository&endpointId={{ _endpoint_resolved_id }}"
    method: POST
    validate_certs: false
    headers: "{{ _portainer_auth_headers }}"
    body_format: json
    body:
      Name: "{{ _name }}"
      StackFilePath: "{{ _compose_path }}"
      RepositoryURL: "{{ _repo_url }}"
      RepositoryReferenceName: "{{ _git_ref }}"
      ComposeFormat: 2
      Env: "{{ _env }}"
    status_code: [200, 201, 409, 405]
  register: _recreate_try
  when:
    - _existing_stack_id | string | length > 0
    - _must_recreate_from_repo