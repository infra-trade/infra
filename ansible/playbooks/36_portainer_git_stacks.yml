---
# playbooks/36_portainer_git_stacks.yml
# Crea/actualiza stacks en Portainer desde Git usando alias -> endpointId dinámico.

- name: Create/Update Portainer stacks from Git (dynamic endpointId)
  hosts: mon-core
  become: false
  gather_facts: yes

  vars:
    # Lee token desde ENV (recomendado) o desde un var seguro/vault si lo defines aparte
    portainer_api_key: "{{ lookup('env', 'PORTAINER_TOKEN') | default('', true) }}"
    # De group_vars/all.yml:
    # portainer_url, portainer_validate_certs, stacks, endpoint_aliases

  pre_tasks:
    - name: Assert API token present
      assert:
        that:
          - portainer_api_key | length > 0
        fail_msg: "PORTAINER_TOKEN no está definido (exporta PORTAINER_TOKEN en el controlador)."
        success_msg: All assertions passed

    - name: Assert required variables exist
      assert:
        that:
          - portainer_url is defined
          - portainer_validate_certs is defined
          - stacks is defined
          - endpoint_aliases is defined
        fail_msg: "Faltan variables requeridas (portainer_url, portainer_validate_certs, stacks, endpoint_aliases)."
        success_msg: Basic variables present.

    - name: Wait for TCP {{ portainer_url | urlsplit('hostname') }}:{{ portainer_url | urlsplit('port') | default(9443) }}
      wait_for:
        host: "{{ portainer_url | urlsplit('hostname') }}"
        port: "{{ (portainer_url | urlsplit('port')) | default(9443) | int }}"
        delay: 0
        timeout: 60

    - name: Wait for /api/status (no auth)
      uri:
        url: "{{ portainer_url }}/api/status"
        method: GET
        validate_certs: "{{ portainer_validate_certs | default(false) }}"
        return_content: true
        follow_redirects: all
        status_code: 200
      register: status_check
      retries: 6
      delay: 5
      until: status_check.status is defined and status_check.status == 200

    - name: Portainer connectivity check (with API key)
      uri:
        url: "{{ portainer_url }}/api/system/status"
        method: GET
        headers:
          X-API-Key: "{{ portainer_api_key }}"
        validate_certs: "{{ portainer_validate_certs | default(false) }}"
        follow_redirects: all
        status_code: 200
        return_content: true
      register: system_status

    - name: Fail with clear message if API check != 200
      fail:
        msg: "Conectividad a Portainer falló (status {{ system_status.status | default('n/a') }}). Revisa URL/cert/token."
      when: system_status.status | default(0) != 200

    - name: Show connectivity check result (safe)
      debug:
        msg: "Portainer system/status OK (200)."

  tasks:
    #####################################################################
    # 1) Obtener endpoints (dejamos visible para ver el error real)
    #####################################################################
    - name: Get endpoints list
      uri:
        url: "{{ portainer_url }}/api/endpoints?limit=1000"
        method: GET
        headers:
          X-API-Key: "{{ portainer_api_key }}"
        validate_certs: "{{ portainer_validate_certs | default(false) }}"
        follow_redirects: all
        return_content: true
        status_code: 200
      register: endpoints_resp
      retries: 4
      delay: 3
      until: endpoints_resp.status is defined and endpoints_resp.status == 200

    - name: Debug endpoints raw (ayuda a diagnosticar si falla)
      debug:
        var: endpoints_resp.json
      when: endpoints_resp.json is defined

    - name: Build alias->endpointId map from Portainer
      set_fact:
        endpoint_name_to_id: >-
          {{
            dict(
              (endpoints_resp.json | default([]))
              | selectattr('Name', 'defined')
              | selectattr('Id', 'defined')
              | map('extract', attribute=None)
              | map('combine', [{'k': item.Name, 'v': item.Id}] ) | list
            )
          }}
      vars:
        # pequeño truco para poder usar map('combine'): construimos pares k/v
        item: "{{ item }}"
      loop: "{{ endpoints_resp.json | default([]) }}"
      loop_control:
        label: "{{ item.Name | default('unknown') }}"
      when: endpoints_resp.json is defined
      register: __tmp_ep_map
      changed_when: false

    - name: Collapse map result
      set_fact:
        endpoint_name_to_id: "{{ dict( __tmp_ep_map.results | map(attribute='ansible_facts.endpoint_name_to_id') | select('defined') | map('items') | sum(start=[]) ) }}"
      when: __tmp_ep_map is defined
      changed_when: false

    - name: Resolve endpointId for each stack using endpoint_aliases
      set_fact:
        stacks_resolved: >-
          {{
            stacks | map('combine',
              {
                'endpointId':
                  (
                    endpoint_name_to_id[
                      endpoint_aliases[item.endpoint] | default(item.endpoint)
                    ]
                    if (endpoint_name_to_id is defined and
                        (endpoint_aliases[item.endpoint] | default(item.endpoint)) in endpoint_name_to_id)
                    else omit
                  ),
                'endpoint_name':
                  endpoint_aliases[item.endpoint] | default(item.endpoint)
              }
            )
          }}
      vars:
        item: "{{ item }}"
      loop: "{{ stacks }}"
      register: stacks_with_endpoints
      changed_when: false

    - name: Fail if some stack has unresolved endpointId
      vars:
        unresolved: >-
          {{
            (stacks_with_endpoints.results | map(attribute='ansible_facts.stacks_resolved') | list | first)
            | selectattr('endpointId', 'undefined')
            | list
          }}
      fail:
        msg: >-
          No se pudo resolver endpointId para algunos stacks:
          {{ unresolved | map(attribute='name') | list }}.
          Verifica que endpoint_aliases mapee a nombres EXACTOS de Portainer (endpoint.Name)
          y que ese nombre aparezca en /api/endpoints.
      when: >-
        ((stacks_with_endpoints.results | map(attribute='ansible_facts.stacks_resolved') | list | first)
        | selectattr('endpointId', 'undefined') | list | length) > 0

    - name: Set final stack list
      set_fact:
        stacks_final: "{{ (stacks_with_endpoints.results | map(attribute='ansible_facts.stacks_resolved') | list | first) }}"

    #####################################################################
    # 2) Crear/actualizar stacks desde Git
    #####################################################################
    - name: Upsert stack from Git (create or update)
      vars:
        endpoint_id: "{{ item.endpointId }}"
        repo_url: "{{ item.repo_url }}"
        repo_ref: "{{ item.git_ref | default('main') }}"
        compose_path: "{{ item.compose_path }}"
        stack_name: "{{ item.name }}"
        env_vars: "{{ item.env | default([]) }}"
      block:
        # Intentar UPDATE primero (si existe el stack)
        - name: Get stack by name
          uri:
            url: "{{ portainer_url }}/api/stacks?filters=%7B%22name%22:%5B%22{{ stack_name | urlencode }}%22%5D%7D"
            method: GET
            headers:
              X-API-Key: "{{ portainer_api_key }}"
            validate_certs: "{{ portainer_validate_certs | default(false) }}"
            follow_redirects: all
            return_content: true
            status_code: 200
          register: stack_lookup

        - name: Decide create or update
          set_fact:
            __existing_stack: "{{ (stack_lookup.json | selectattr('Name','equalto', stack_name) | list | first) | default(None) }}"
            __env_dict: "{{ dict(env_vars | map(attribute='name') | list | zip(env_vars | map(attribute='value') | list)) }}"

        - name: Update stack from Git if exists
          when: __existing_stack is not none
          uri:
            url: "{{ portainer_url }}/api/stacks/{{ __existing_stack.Id }}"
            method: PUT
            headers:
              X-API-Key: "{{ portainer_api_key }}"
            validate_certs: "{{ portainer_validate_certs | default(false) }}"
            follow_redirects: all
            status_code: 200
            body_format: json
            body:
              # Repositorio Git
              RepositoryURL: "{{ repo_url }}"
              RepositoryReferenceName: "{{ repo_ref }}"
              ComposeFilePathInRepository: "{{ compose_path }}"
              # Endpoint al que está ligado el stack
              EndpointID: "{{ endpoint_id | int }}"
              # Variables de entorno
              Env: "{{ env_vars | default([]) }}"
              # Forzar pull de repo
              PullImage: true

        - name: Create stack from Git if not exists
          when: __existing_stack is none
          uri:
            url: "{{ portainer_url }}/api/stacks/create?type=2&method=repository&endpointId={{ endpoint_id | int }}"
            method: POST
            headers:
              X-API-Key: "{{ portainer_api_key }}"
            validate_certs: "{{ portainer_validate_certs | default(false) }}"
            follow_redirects: all
            status_code: 200
            body_format: json
            body:
              Name: "{{ stack_name }}"
              RepositoryURL: "{{ repo_url }}"
              RepositoryReferenceName: "{{ repo_ref }}"
              ComposeFilePathInRepository: "{{ compose_path }}"
              SwarmID: ""
              Env: "{{ env_vars | default([]) }}"
              Prune: true
      loop: "{{ stacks_final }}"
      loop_control:
        label: "{{ item.name }}"